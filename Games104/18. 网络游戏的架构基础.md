- Basics 
	- Network Protocols 
		- TCP, UDP and Reliable UDP 
	- Clock Synchronization 
	- Remote Procedure Call (RPC) 
	- Network Topology 
	- Game Synchronization 
		- Snapshot Sync. 
		- Lockstep Sync. 
		- State Sync.
- Advanced 
	- Character Movement Replication 
	- Hit Registration 
	- Lag Compensation 
	- MMO Game Network Architecture 
	- AOI 
	- Anticheat 
	- The Future


### Network Protocols
- How to communication between two PCs
	- A and B must agree on the meaning of the bits being sent and received at many different levels, including 
		- How many volts represents a 0 bit, and for a 1 bit? 
		- How does receiver know which is the last bit? 
		- How many bits long is a number?
- Transmission Control Protocol (TCP)
	- Connection-Oriented 
	- Reliable and Ordered 
	- Flow Control 
	- Congestion Control
- UDP Features
	- Connectionless 
	- UnReliable and Unordered 
	- NO Flow Control 
	- NO Congerstion Control
- TCP VS UDP
	- 对比图![[Pasted image 20230124104503.png]]
- Reliable UDP
	- TCP is Not Time Critical
		- TCP is the complex and heavyweight protocol. It provides reliable delivery and advanced features, but it has more overhead 
		- TCP is a fair, traffic oriented protocol designed to improve bandwidth utilization. But it's not designed for speed
	- UDP is Fast but Unreliable
		- UDP is lightweight and fast but unreliable, packet loss and disorder will occur 
	- Why We Need to Customize Protocol
		- Game Server（对于服务器来讲，需求如下） 
			- Keep-alived connection (TCP) 
			- Need keep logic consistency in “order” (TCP) 
			- High responsive & low latency (UDP) 
			- Broadcast commonly used (UDP) 
	- 实现方式
		- Acknowledgement & Sequence Number
			- Positive acknowledgment (ACK) is a signal that is passed between communicating processes, computers, or devices to signify acknowledgment, or receipt of message •
			- Negative ACK (NACK or NAK) is a signal that is sent to reject a previously received message or to indicate some kind of error 
			- Sequence number (SEQ) is a counter used to keep track of every byte sent outward by a host 
			- Timeouts specified periods of time allowed to elapse before an acknowledgment is to be received
		- Automatic Repeat Request (ARQ)
			- An error-control method for data transmission that uses ACK and timeouts to achieve reliable data transmission over an unreliable communication channel. 
			- If the sender does not receive an acknowledgment before the timeout, it re-transmits the packet until it receives an acknowledgment or exceeds a predefined number of retransmissions 
				- Sliding window protocol 
					- Stop-and-Wait ARQ 
					- Go-Back-N ARQ 
					- Selective Repeat ARQ
			- what is Sliding window protocol
				- Send mutilple frames at a time, number of frames to be sent is based on Window size 
				- Each frame is numbered by Sequence number 
				- When the frame at the front of the window is received, the window slides![[Pasted image 20230124105806.png]]
				- 窗口滑动策略
					- Stop-and-Wait ARQ
						- Windows size = 1 
						- After transmitting one frame, the sender waits for an ACK before transmitting the next frame 
						- If the ACK does not arrive after a certain time, the sender times out and retransmits the original frame 
						- Poor utilization of bandwidth, poor performance![[Pasted image 20230124105914.png]]
					- Go-Back-N ARQ
						- N is Sender's Windows Size 
						- The Receiver only sends cumulative ACK 
						- If an ACK is not received within an agreedupon time period, all frames in the current window are transmitted![[Pasted image 20230124110016.png]]
					- Selective Repeat ARQ
						- In Selective Repeat ARQ, only the damaged or lost frames are retransmitted 
						- The receiver sends the ack of each frame, and the sender maintains the timeout time of each frame 
						- When receiver receive damaged packet, it will send a NACK, The sender will send/retransmit frame for which NACK is received![[Pasted image 20230124110042.png]]
		- Make UDP Reliable in Packet Loss Scenario
			- With the increase of packet loss rate and delay, the reliable UDP can not meet the transmission requirements gradually.eg.If packet loss rate increase to 20%, use reliable UDP is still with high delay
			- Forward Error Correction (FEC)
				- The transmission of enough additional redundant information with the primary data stream to reconstruct lost IP packets up to a certain extent![[Pasted image 20230124111327.png]]
				- Reduce packet loss rate, but cost addtional bandwidth 
				- The packet loss rate is high, the effect of packet loss compensation is more obvious 
				- Two FEC algorithms 
					- XOR FEC 
					- Reed-Solomon Codes
				- XOR-FEC![[Pasted image 20230124111421.png]]
				- Reed-Solomon Codes
					- 1![[Pasted image 20230124111454.png]]
					- 2![[Pasted image 20230124111503.png]]
					- 3![[Pasted image 20230124111512.png]]
	- Customize Your UDP based on ARQ and FEC
		- Reliability 
			- Use Selective Repeat ARQ
		- Hybrid ARQ and FEC 
			- Before ARQ, FEC is used for error correction
		- Real-time 
			- Smaller RTO growth 
			- No congestion control 
			- Fast retransmission mechanism 
			- No delay ACK
		- Flexibility 
			- Design protocol for speed 
			- Support both reliable and unreliable transmission


### Clock Synchronization
- Round-Trip Time（RTT）
	- Send/Recv delay
	- Propagation delay
	- Response time of the origin server
- RTT vs. Ping
	- Ping tests are usually performed within a transport protocol that uses ICMP packets 
	- RTT is measured at the application layer
- RTT vs. Latency
	- Latency is the time required for a data packet to travel from the sending endpoint to the receiving endpoint (only one trip)
- Network Time Protocol (NTP)
	- Network Time Protocol is an internet protocol used to synchronize with computer clock time sources in a network
	- Reference clock 
		- GPS clock or radio ransmiiting station 
		- Amazinglly precise timekeeping devices such as atomic clocks 
		- Not connected to the internet 
		- Send their time through radio or optical fiber
	- NTP Algorithm
		- Client ask time server for time
		- Server receives the request and reply
		- Client receives the reply
		- 计算方式![[Pasted image 20230124133002.png]]
		- 举个例子![[Pasted image 20230124133043.png]]
	- NTP算法有个隐式的条件，上行带宽等于下行带宽，但是实际上很难相等。
	- Stream-Based Time Synchronization with Elimination of Higher Order Modes
		- 使用这个方式可以逼近服务器的时间，但是不可能完全相等
		- 建立链接的第一步就是要同步时间。
		1. Client stamps current local time on a "time request" packet and sends to server 
		2. Upon receipt by server, server stamps server-time and returns
		3. Upon receipt by client, a time delta is calculated by delta = (current Time-sent Time) / 2
		4. The first result should immediately be used to update the clock
		5. The client repeats Steps 1-3 (NTP-like process), five or more times 
		6. The results of the packet receipts are accumulated and sorted in ascending order by latency 
		7. All samples above that are approximately 1.5 times the median are discarded, and the remaining samples are averaged using an arithmetic mean


### Remote Procedure Call (RPC)
- Socket Programming, Lots for the programmer to deal with every time 
	- How to separate different requests on the same connection? 
	- How to write bytes to the network/read bytes from the network? 
	- What if Host A's process is written in Go and Host B’s process is in C++? 
	- What to do with those bytes?
- Communication with Messages
	- Initially, people "hand-coded" messages to send requests and responses 
		- Message is a stream of bytes – "op codes" and operands
	- Lots of drawbacks 
		- Need to worry about message format 
		- Have to pack and unpack data from messages 
		- Servers have to decode messages and dispatch them to handlers 
		- Messages are often asynchronous 
		- After sending one, what do you do until the response comes back? 
		- Messages aren’t a natural programming model
- More Challenges on Logic Communication
		- For a remote procedure call, a remote machine may: 
			- Run process written in a different language 
			- Represent data types using different sizes 
			- Use a different byte ordering (endianness) 
			- Represent floating point numbers differently 
			- Have different data alignment requirements e.g., 4-byte type begins only on 4-byte memory boundary
- Remote Procedure Call (RPC)
	- RPC is a request–response protocol. An RPC is initiated by the client, which sends a request message to a known remote server to execute a specified procedure with supplied parameters![[Pasted image 20230124135017.png]]
	- Goals 
		- Ease of programming 
		- Hide complexity 
		- Familiar model for programmers (just make a function call)
- Why RPC?
	- Goal: Easy-to-program network communication that makes client-server communication transparent
		- Retains the "feel" of writing centralized code 
			- Programmers needn't think about the network 
			- Make communication appear like a local procedure call 
		- Don't need to worry about serialization/deserialization for network 
		- Don't need to worry about complexities of network
- Interface Definition Language
	- A server defines the service interface using an interface definition language (IDL)
	- The IDL specifies the names, parameters, and types for all client-callable server procedures
		- example: Protobuf (Google's data interchange format)
- RPC Stubs
	- A client-side stub is a procedure that looks to the client as if it were a callable server procedure 
		- The client program thinks it's invoking the server but it's calling into the client-side stub
	- A server-side stub looks like a caller to the server 
		- The server program thinks it's called by the client but it's really called by the server-side stub
	- The stubs send messages to each other to make the RPC happen transparently
	- ![[Pasted image 20230124135403.png]]
- Stub Compiler
	- A "stub compiler" reads the IDL declarations and produces two stub procedures for each server procedure 
		- The server programmer implements the service's procedures and links them with the server-side stubs 
		- The client programmer implements the client program and links it with the client-side stubs 
		- The stubs manage all of the details of remote communication between client and server
- Real RPC Package Journey
	- 流程图![[Pasted image 20230124135534.png]]



### Network Topology
- Original Peer-to-Peer (P2P)
	- Each client broadcasts game event to the all others 
	- Robustness 
	- Cheating is much easier 
	- Synchronization is required among all nodes to maintain the consistency of the distributed game state
- P2P with Host Server
	- A player can act as "server", known as host 
	- If host disconnected, the game may end 
	- The host need to handle game actor that can not be controled by players, such as bot
- P2P Games（可以用P2P方式的游戏）
	- No rely on server 
	- Used in Lan commonly 
	- The “Host” is basically in control of the sessions 
	- A limited number of players at once
- Dedicated Server
	- Authority 
	- Simulate game world 
	- Dispatch data to players 
	- High performance requirements
- P2P VS Dedicated Server
	- 对比![[Pasted image 20230124152046.png]]
- When RTT is too high
	- When players are in different countries, far away, or when the network environment is complex 
	- Use dedicated line and edge gateway to reduce latency（在城市里面设立专门的网关，网关直连服务器，不通过公网路由，来保证低延迟）



### Game Synchronization
- Synchronization Methods
	- Snapshot（quake）
	- Lockstep（Honor of Kings， doom）
	- State Synchornization（Counter Strike）

### Snapshot Synchronization
- 流程
	- Client sends inputs to server
	- Server simulates the game world 
	- Generates whole game state snapshots 
	- Sends them down to clients 
	- Client updates the display according to the snapshot
- Jitter and Hitches（抖动和障碍）
	- Server tick rate is limited
		- Performance 
		- Bandwidth
- 改进
	- Snapshot Interpolation
		- Not rendering immediately after snapshot recevied 
		- Keep an interpolation buffer 
		- Interpolation between the two delayed snapshots
	- Delta Compression
		- Only sync snapshot delta to client 
		- Example Quake3
- 总结
		- Client performance is wasted 
		- High server pressure 
		- High data volume and high bandwidth requirements 
		- As games get more complex, snapshots get bigger

### Lockstep Synchronization
- Lockstep synchronization, used in military simulation, is by far the simplest techique to ensure consistency
	- Same Result 
		- Same time 
		- Same action
- Lockstep Principle
	- 概念![[Pasted image 20230124154336.png]]
- First Game Used Lockstep
	- The network synchronization method of DOOM (1994) was pointed out in a 2006 paper 
	- Lockstep is not mentioned in the paper, but it is now generally accepted that Doom (1994) was the first multiplayer FPS online game to use this type of synchronization 
	- It uses P2P architecture
	- 格斗游戏，moba类，实时性要求高，要求准确性的经常使用lockstep
- Lockstep Initialization
	- Ensure that the initial data of each client is deterministic 
		- Game model 
		- Static data 
		- ... 
	- Synchronize clock
- Deterministic Lockstep（偏向准确性，对网络差者有利）
	- 流程
		- 流程图![[Pasted image 20230124154746.png]]
		- Client sends inputs to Server 
		- Server receives and sorts 
		- Wait for input from all clients before forwarding 
		- After receiving data from the server, the client executes the game logic
	- 缺点
		- Game progress depends on slowest player 
		- The delay of the game is not fixed, the experience is not good 
		- All the players will wait if a player offline
- Bucket Synchronization（更偏向实时性，对网络好者有利）
	- 流程图![[Pasted image 20230124154909.png]]
	- Bucket: a fixed time period 
	- Each bucket 
		- Collect all instructions 
		- Broadcast to all players 
	- There is no need to wait for all players' commands to be received before forwarding
- Deterministic Difficulties
	- Deterministic 
		- The same input sequence need to produce the same game state on all machines
	- Deterministic is Hard 
		- Floating point 
			- 为什么不能用浮点数
				- Because of the computer binary, These numbers can be accurately represented
					- 0.5 = 1/2 
					- 0.25 = 1/4 
					- 0.75 = 1/2+1/4 
					- 0.875 = 1/2+1/4+1/8
				- Such numbers can only be approximated 
					- 2/3 ≈ 0.66..7
				- Floating point numbers must comply with the IEEE 754 standard
				- But different platforms may have different behavior![[Pasted image 20230124171302.png]]
			- 解决方式: Avoid problems on the precision boundary, customize the precision
				- Fixed-point math library 
					- A fixed-point number can be split into three parts
						- An optional sign bit 
						- An integer 
						- A fractional part 
						- Need to implement addition, subtraction, multiplication and division etd. 
						- Implement class, class methods 
						- Performance needs to be considered
				- Look-up table (trigonometric functions, etc.) 
				- Amplification and truncation
				- Simple method 
					- Multiply by 1000, then divide by 1000, there is an overflow risk 
					- The numerator and denominator are represented by fixed-point numbers (2/3)
		- Random number 
			- 问题：Random problems in the game 
				- Trigger of random events, npc random birthplace 
				- A random attribute of the attack, e.g. critical strike chance 
				- ...
				- These logics are generally implemented with random numbers 
			- 解决方式：
				- Random numbers are pseudorandom 
				- Before the game starts, initialize the random number seed 
				- For different players' clients, the number of random function calls is fixed, and the generated random numbers are the same
		- Containers and algorithms (sort, add, remove, etc.) 
		- Math tools (vectors, quaternions, etc) 
		- Physics simulation (very difficult) 
		- Code logic execution order
- Tracing and Debugging
	- Method of get checksum
		- All data checksum 
		- Key data checksum 
		- Other methods
	- Automatically locate BUG
		- Server compares different client's checksums 
		- Client uploads 50 frames of full logs 
		- Find inconsistencies in the compared logs
	- 数据校验![[Pasted image 20230124171910.png]]
- Lag and Delay
	- Client send operation
	- Receive the operation of this frame from the server 
	- execute
	- Lag
		- Network is unstable. If you wait until you receive new frame, there will be a lag
	- Solution 
		- use buffer to cache frames 
		- Large buffer, large delay 
		- Small buffer, sensitive to lag
	- 流程图![[Pasted image 20230124181918.png]]
- Separating Game Logic from Rendering
	- Lag problem 
		- Separation of logic and rendering • Local client-side interpolation smoothing
	- Frame rate 
		- The logical frame rate is generally 10~30 frames 
		- The rendering frame rate is generally higher
	- Advantage 
		- Different frequencies, independent operation 
		- Rendering separation to avoid tearing and freezing 
		- Rendering freezes, does not affect the operation of logical frames 
		- Servers can run logic frames to solve some cheating problems 
		- If the server runs logical frames, it can save key frame snapshots to speed up reconnection
- Reconnection Problem
	- Offline
	- Reconnect
	- Catch up
	- 解决方式
		- Client Game State Snapshots
			- Snapshots can be saved regularly on the local client and serialized to disk 
			- When reconnection occurs, restore the game state from the disk serialized data 
			- Server sends player commands after snapshot 
			- Accelerate to catch up with the game progress
			- 客户端本地保存快照，重连回来的时候从最后缓存的快照开始追帧
		- Server State Snapshot Optimization
			- The server runs logical frames and saves snapshots of keyframes 
			- The server sends the snapshot, and the player commands after the snapshot 
			- Accelerate to catch up with the game progress
	- Observing（观战）
		- Reconnecting and watching are essentially the same 
		- Watching is similar to reconnecting after a client crash 
		- Player action command, forwarded to the player watching the game 
		- Watching is usually delayed for a few minutes to prevent screen peeping
	- Replay（精彩时刻，重放）
		- Execute player commands in order which can speed up
			- Replay file 
				- Save game commands for a game 
				- Files take up little space
			- How to implement go back? 
				- When the client executes the replay file, it adds a key frame snapshot, which can go back to the key frame moment 
				- The current version of Honor of Kings go back to the key frame before 60s
- Lockstep Cheating Issues
		- Multiplayer-PVP 
			- Game over 
				- The client uploads the key data checksum, the server verifys the game result 
			- During the game 
				- Report the key data checksum • Cheating players are kicked out, etc.
		- 2 Players 
			- Server can not detect who is cheating using key data checksum 
			- If the server is not verified, the cheating player will only affect one player in this case
		- Difficult to avoid thirty-party plug-in to access war-fog or other hidden data 
			- Game logic is performed on the client side 
			- Clients have all the game data
- Lockstep Summary
		- Advantages 
			- Low bandwidth, only sends commands 
			- High development efficiency, similar to single-player game development 
			- Precise action/hit detection 
			- Easy to record games
		- Problems 
			- Maintain （保持）the consistency （一致性）is difficult to achieve 
			- Hard to solve the cheat plugin to unveil all game states 
			- Longer disconnection and reconnection time 
				- Need more complex optimization


### State Synchronization
- MMORPG，FPS
- 同步哪些东西呢
	- state data，状态数据，比如位置血量
	- Events，爆炸事件，命中事件
	- contorl data，玩家的输入
- State 
	- The game state is necessary to represent the game world. e.g: HP, MP
- State Synchronization 
	- Server does not generate a single update for all clients. It sends client a customized data packet ，客户端只会模拟自己周围的世界，服务器会模拟整个世界
	- If the game world is too complex, you can set an Area Of Interest (AOI) for reducing server overhead
- 状态同步流程图![[Pasted image 20230124183813.png]]
- Authorized and Replicated Clients
	- Authorized (1P) （玩家自己）
		- Player's local game client
	- Server 
		- Authorized server
	- Replicated (3P)（其他玩家） 
		- Simulated character in other player's client
- Dumb Client Problem
	- Clients can not to do anything until receive server state update，客户端做出操作后要等一个rtt才能做出动作
	- How to see an immediate response?
		- Client-side prediction 
			- The client is always ahead of the server by half RTT and one buffered command frame
			- Press key and response immediately
			- 客户端操作后立即执行，等服务器回包之后，看一下
		- Server reconciliation
			- Record every state when do the client prediction 
			- Compare with the past server data when it was received on client side
- Packet Loss
	- Client input packages fail to reach the server 
	- The server tries to keep tiny input buffer of unprocessed input 
	- If the server run out of input buffer, server will duplicate your last input in a window 
	- Push client sends missed inputs asap


### State Synchronization Vs. Lockstep Synchronization
![[Pasted image 20230124211300.png]]
