- Navigation
- Steering
- Crowd Simulation 
- Sensing 
- Classic Decision Making Algorithms

### Navigation
- Navigation Steps
	- Map representation
		- Walkable Area
			- We need to tell AI agents where they can walk â€“ Walkable area
			- åŒä¸€ä¸ªåœ°å›¾å¯¹äºä¸åŒçš„agentå¯è¡Œèµ°åŒºåŸŸå¯èƒ½æ˜¯ä¸ä¸€æ ·çš„ï¼Œæ¯”å¦‚å£«å…µå’Œå¦å…‹ï¼Œé£æœº
			- Walkable area of players is determined by character motion capabilities
				- Physical Collision
				- Climbing slope/height
				- Jumping distance
			- Simulating movement of AI agents as players costs too much
			- AI agents are still expected to have the same walkable area as players
			- å¯è¡Œèµ°åŒºåŸŸè¡¨è¾¾å½¢å¼
				- Waypoint Network
					- Network connecting critical points (waypoints) from the map
					- Waypoint sources: 
						- Designed important locations 
						- Corner points to cover walkable area 
						- Internal points to connect near-by waypoints adding flexibility to navigation
					- Usage of waypoint network is similar to subway system
						- Find the nearest points to get on and off the network
						- Plan the path on the waypoint network
					- Pros:
						- Easy to implement
						- Fast path finding, even for large maps 
					- Cons: 
						- Limited flexibility: must go to the nearest point in the network before navigation 
						- Waypoint selection requires manual intervention
				- Grid 
					- Intuitive discretization of map
					- Uniform subdivision into small regular grid shapes
					- Common grid shapes 
						- Square
						- Triangle 
						- Hexagon
					- Grid property could be modified in runtime to reflect dynamic environmental changes
					- Pros: â€¢
						- Easy to implement 
						- Uniform data structure 
						- Dynamic 
					- Cons: 
						- Accuracy depends on grid resolution
						- Dense grid lowers pathfinding performanceï¼Œæ ¼å­å¾ˆå¯†é›†çš„è¯ï¼Œæ•ˆç‡ä¼šä½ï¼Œå› ä¸ºçº¿æ€§çš„å­˜å‚¨æ–¹å¼å¯¼è‡´cache miss
						- High memory consumption 
						- Hard to handle 3D mapï¼Œå¾ˆéš¾è¡¨è¾¾å±‚æ¬¡ç»“æ„ï¼Œæ¯”å¦‚æ¡¥
				- Navigation Mesh
					- Solves the problem of representing overlapped walkable areas 
					- Approximates the walkable area of character controller based on physical collision and motion capabilities
					- Lowers network density to boost pathfinding performance
					- Convex Polygon of NavMesh
						- Pathfinding generates a series of polygon (Polygon Corridor) need to walk through
						- Convexity guarantees the final path is limited in the polygon and two adjacent polygons have only one common edge (Portal)ï¼ˆä¸¤ä¸ªå‡¸å¤šè¾¹å½¢ä¹‹é—´åªä¼šæœ‰ä¸€ä¸ªå…¬å…±è¾¹ï¼‰
						- å¯»è·¯çš„æ—¶å€™è¦ç©¿è¿‡ä¸€ä¸ªå‡¸å¤šè¾¹å½¢ï¼Œåªä¼šç©¿è¿‡ä¸€æ¬¡ï¼Œå¦‚æœæ˜¯å‡¹å¤šè¾¹å½¢ï¼Œå¯èƒ½ä¼šæœ‰å¤šæ¬¡
					- Pros: 
						- Support 3D walkable surface 
						- Accurate ï¼ˆç²¾ç¡®ï¼‰
						- Fast in pathfinding 
						- Flexible for selection of start/destination 
						- Dynamic 
					- Cons: 
						- Complex generation algorithm 
						- Not support 3D spaceï¼ˆä¸èƒ½ç»™ç›´å‡é£æœºè¿™ç§agentå¯»è·¯ï¼‰
				- Sparse Voxel Octreeï¼ˆå…«å‰æ ‘ï¼‰
					- Represents â€œflyableâ€ 3D space
					- Similar to spatial partitioning
					- Finest level voxels represents complicated boundary
					- Coarser-level voxels represents uniform regions
					- å­˜å‚¨æ¯”è¾ƒè´¹ï¼Ÿ
					- å¯»è·¯æ¯”è¾ƒéº»çƒ¦ï¼Ÿ
	- Path finding
		- Distances in map representations can be abstracted as edge costs in graph![[Pasted image 20230122131030.png]]
		- Pathfinding can be abstracted as shortest path problem in non-directional graph
		- Depth-First Search
			- Expand most recently added
		- Breadth-First Search
			- Expand least recently added
		- Dijkstra Algorithm
		- A Star (A*)
			- implement![[Pasted image 20230122143215.png]]
			- Expand lowest cost in list 
			- Distance is known distance from source + heuristic 
			- Greedy: stops when reaches the goal
			- Cost calculation
				- Cost calculation: ğ‘“ ğ‘› = ğ‘”(ğ‘›) + â„(ğ‘›) 
				- ğ‘”(ğ‘›): the exact cost of the path from the start to node ğ‘› 
				- â„(ğ‘›): the estimated cost from node ğ‘› to the goal
			- Heuristic On Grids
				- For 4 directions of movement, we can use Manhattan distance
				- ğ·1: cost for moving to the adjacent node
				- â„(ğ‘›) = ğ·1 âˆ™ (ğ‘‘ğ‘¥ + ğ‘‘ğ‘¦)
					- ğ‘‘ğ‘¥ = |ğ‘¥ğ‘› âˆ’ ğ‘¥ğ‘”ğ‘œğ‘ğ‘™| , ğ‘‘ğ‘¦ = |ğ‘¦ğ‘› âˆ’ ğ‘¦ğ‘”ğ‘œğ‘ğ‘™|
			- Heuristic On NavMesh
				- Multiple choices when evaluating cost on NavMesh 
					- Using polygon centers or vertices usually over-estimateï¼ˆè¿‡é«˜ä¼°è®¡ï¼‰ the cost 
					- Using hybridï¼ˆæ··åˆï¼‰ method introducesï¼ˆå¼•å…¥ï¼‰ too many points to check
					- Midpoints of edges â€“ a good balance
				- On a navigation mesh that allows any angle of movement, use a straight line distance 
				- Use midpoint of the edge entering the current node as node cost calculation point 
				- ğ·: the cost for moving unit distance in any direction
					- â„(ğ‘›) = ğ· âˆ™ æ¬§æ‹‰è·ç¦»
			- Heuristic
				- â„(ğ‘›) controls A* behavior:
					- With 100% accurate estimates, get shortest paths quickly
					- Too low, continue to get shortest paths, but slow down
					- Too high, exit early without shortest path
				- Balance between pathfinding speed and accuracy
	- Path smoothing
		- Why we need path smoothing â€¢
			- Zigzag, many unnecessary turns ï¼ˆè·¯å¾„å¾ˆæ›²æŠ˜ï¼‰
		- â€œString Pullingâ€ â€“ Funnel Algorithmï¼ˆçƒŸå›±ç®—æ³•ï¼‰
			- The scope of the funnel is the possible scope of the path 
			- Narrow the funnel if necessary to fit the portal
			- Terminate when the goal is in the funnel
			- å›¾1![[Pasted image 20230122143904.png]]
			- å›¾2![[Pasted image 20230122143915.png]]
	- NavMesh Generation 
		- Voxelization
			- Sample collision scene by voxelization
		- Region Segmentation
			- Calculate the distance of each voxel to border 
			- Mark border voxels by AgentRadius to avoid clipping
			- Watershed Algorithm
				- Gradually â€œfloodâ€ the â€œterrainâ€ 
				- Form â€œwatershedâ€ (dividing ridge) when â€œpoolsâ€ meet
			- Segment the â€œneighboringâ€ voxels into regions to provide a good basis for polygon mesh
			- Regions donâ€™t have overlapping voxels in 2D
		- Mesh Generation
			- Generate NavMesh from segmented regions
	- NavMesh Advanced Features
		- Polygon Flag
			- Useful for marking terrain types: plains, mountain, water, etc. 
				- â€œPaint colorsâ€ to add user-defined regions 
				- Polygons generated from user-defined regions have special flag
		- Tile
			- æŠŠä¸–ç•Œåˆ†å—ï¼Œéšœç¢ç‰©ç§»åŠ¨çš„è¯ï¼Œåªæ›´æ–°éšœç¢ç‰©æ‰€åœ¨çš„å—çš„navmesh
			- Fast for responding to dynamic objects 
			- Avoid rebuilding the entire NavMesh 
			- TileSize â€“ trade-off between pathfinding and dynamic rebuilding performance
		- Off-mesh Link
			- Allow agents to jump or teleport


### Steering
- From Path to Motion
	- Cars cannot follow planned path exactly 
	- Motion of cars are limited by theirs motion abilities: 
		- Linear acceleration (throttle/brake) 
		- Angular acceleration (steering force) 
	- Motion needs to be adjusted according to the limits
- Steering Behaviors
	- è¡Œä¸ºåˆ†ç±»[[Stear Behaviors.canvas]]
	- Seek / Flee
		- Steer the agent towards / away from the target
		- Position matching in the nature 
		- Accelerate with max acceleration towards / away from the target
		- Will oscillate around the target
		- Input: 
			- Self position 
			- Target position 
		- Output: 
			- Acceleration
	- Seek / Flee Variations
		- Modifying the target in runtime can generate new steering behaviors
		- Pursue
		- Path Following
		- Wander
		- Flow Field Following
	- Velocity Match
		- Matches the target velocity
		- Calculate acceleration from matching time and velocity differences 
		- Clamp the acceleration by maximum acceleration of agents
		- Input: 
			- Target velocity 
			- Self velocity 
			- Matching time 
		- Output:
			- Acceleration
	- Align
		- Matches target orientation
		- ä¹Ÿéœ€è¦æœ‰matchçš„è¿‡ç¨‹ï¼Œå…ˆåŠ é€Ÿå†å‡é€Ÿå¹³ç¨³match
		- Input: 
			- Target orientation 
			- Self orientation 
		- Output: 
			- Angular acceleration

### Crowd Simulation
- A large group of individuals share information in the same environment alone or in a group
	- Collision avoidance 
	- Swarming 
	- Motion in formation
- Crowd Simulation Models
	- Started from â€œBoidsâ€ system of Reynolds 
	- Three families of models:
		- Microscopic models ï¼ˆå¾®è§‚ï¼‰
			- â€œBottom-Upâ€ 
			- Focus on individuals 
		- Macroscopic models ï¼ˆå®è§‚ï¼‰
			- Crowd as a unified and continuous entity 
		- Mesoscopic models ï¼ˆæ··åˆï¼‰
			- Divide the crowd into groups
	- Microscopic Models
		- Rule-based Models
			- Flock dynamics of animal crowds as an emergent behavior by modeling motion of each individuals with simple predefined rules:
				- Separation: to steer away from all of its neighbors 
				- Cohesion: to steer towards the â€œcenter of massâ€ 
				- Alignment: to line up with agents close by
	- Macroscopic Models
		- Simulate crowd motion from a macro perspective
			- Treat the crowd as a unified and continuous entity 
			- Control motions with potential field or fluid dynamics 
			- Does not consider interactions between individuals and the environment in individual level
		- Exampleï¼š
			- Flow Field In UE5 MassAI
	- Mesoscopic Models
		- Simulate crowd motion taking care of both details and the whole
			- Divide the crowd into groups 
			- Deals with interactions between groups and individuals in each group 
			- combinations of microscopic models and formation rules or psychological models
- Collision Avoidance ï¼ˆå¯ä»¥è®©AIåšï¼Œä½†æ˜¯ä¼šå¾ˆè´¹ï¼‰
	-  Force-based Modelsï¼ˆåŸºäºåŠ›ï¼‰
		- A mixture of socio-psychological and physical forces influencing the behavior in a crowd 
		- The actual movement of an individual depends on the desired velocity and its interaction with the environment 
		- Can simulate dynamical features of escape crowd panic
		- æ¯ä¸ªå°ä¸ªä½“åˆ¤æ–­ä¸éšœç¢ç‰©çš„è·ç¦»ï¼Œè¶Šè¿‘äº§ç”Ÿè¶Šå¤§çš„æ–¥åŠ›ï¼Œéšœç¢ç‰©å‘¨å›´å»ºç«‹è·ç¦»åœº
		- Pros: 
			- can be extended to simulate more emergent behaviors of human crowds 
		- Cons: 
			- Similar to physics simulation, simulation step should be small enough
	- Velocity-based models
		- Consider the neighbor information to make decisions in velocity space
			- able to simulate in local space 
			- applied to collision avoidance
		- Reciprocal Velocity obstacle methods â€“ Current standard collision avoidance algorithms
			- Velocity Obstacle (VO) 
			- Reciprocal Velocity Obstacle (RVO) 
			- Optimal Reciprocal Collision Avoidance (ORCA)


### Sensingï¼ˆPerceptionï¼‰
- æŠŠsensingçš„é¢‘ç‡å¼€æ”¾å‡ºå»ï¼Œé¿å…å‡ºç°ç“¶é¢ˆ
- ç›¸è¿‘èŒƒå›´å†…çš„agentå…±äº«sensing
- Information
	- Interal Information
	- External Infomation
		- Static Spatial Information
		- Dynamic Spatial Information
		- Character Information
- Internal Information
	- Information of the agent itself 
		- Position 
		- HP 
		- Armor status 
		- Buff status 
		- â€¦ 
	- Can be accessed freely
- Static Spatial Information
	- Navigation Data
	- Tactical Mapï¼ˆæˆ˜æœ¯åœ°å›¾ï¼Œä¸åŒçš„åœ°åŒºæœ‰ä¸åŒçš„ä»·å€¼ï¼‰
	- Smart Object
	- Cover Point
- Dynamic Spatial Information
	- Influence Mapï¼ˆæŸä¸ªåœ°åŒºçš„å¨èƒå€¼åŠ¨æ€å˜åŒ–ï¼Œæ ¹æ®ä¸åŒçš„å¨èƒå€¼ä½œå‡ºååº”ï¼‰
	- Marks on navigation dataï¼ˆéšœç¢ç‰©ä½ç½®çš„å˜åŒ–ï¼‰
	- Sight Area
	- Game Objects
		- æ˜¯ä¸æ˜¯åŒä¸€ä¸ªé˜µè¥ï¼Œæ˜¯ä¸æ˜¯å¯ä»¥çœ‹åˆ°ï¼Œå®ƒèƒ½ä¸èƒ½çœ‹åˆ°æˆ‘
		- Information being sensed from a character
		- Multiple character information can exist for a single character as it can be sensed by multiple agents
		- Usually contains: 
			- Game Object ID 
			- Visibility 
			- Last Sensed Method 
			- Last Sensed Position
- Sensing Simulation
	- Light, sound, and odor travels in space 
	- Have max traveling range 
	- Attenuates in space and time with different patterns 
		- Sight is blocked by obstacles 
		- Smelling ranges shrinks over time 
	- Radiating field can simulate sensing signals 
		- Can be simplified as Influence Map 
		- Agents covered by the field can sense the information


### Classic Decision Making Algorithms
- Finite State Machineï¼ˆFSMï¼‰
	- State
	- Conditions
	- Transition
	- Pros 
		- Easy to implement
		- Easy to understand 
		- Very fast to deal with simple case
	- Cons 
		- Maintainability is bad, especially add or remove state 
		- Reusability is bad, canâ€™t used in other projects or characters 
		- Scalability is bad, hard to modify for complicated case
- Hierarchical Finite State Machine (HFSM)
	- Tradeoff between reactivity and modularity
		- Reactivity: the ability to quickly and efficiently react to changes 
		- Modularity:the degree to which a systemâ€™s components may be separated into building blocks, and recombined
		- å¯ä»¥è§£å†³çŠ¶æ€éå¸¸å¤šå¯¼è‡´æ··ä¹±çš„é—®é¢˜ï¼Œä½†æ˜¯å­çŠ¶æ€æœºé‡Œé¢çš„çŠ¶æ€ä¸èƒ½ç›´æ¥åˆ‡æ¢åˆ°å¦ä¸€ä¸ªå­çŠ¶æ€æœºé‡Œé¢ï¼Œå¿…é¡»è¦é€šè¿‡å›ºå®šçš„å£å­å‡ºå»![[Pasted image 20230122181056.png]]
- Behavior Tree
	- Focus on state abstraction and transition conditions
	- Similar to human thinking
	- Execution Nodes(leaf node)
		- Condition node
			- Self states or perceptions Return true or false
		- Action node
			- Return success or failureï¼Œrunning
	- Control flow node (internal node) 
		- Control flow determined by the return value of child nodes 
		- Each node has a return value which is success, failure or running
		- Sequence 
			- Allows designers to make a â€œplanâ€![[Pasted image 20230122195116.png]]
			- Order 
				- Execute children from left to right
			- Stop Condition and Return Value
				- until one child returns Failure or Runningï¼Œ then return value accordingly 
				- or all children return Successï¼Œthen return Success
			- If Stop and Return Running
				- the next execution will start from the running action
		- Selector
			- Could select one action to do response to different environment ![[Pasted image 20230122195442.png]]
			- Could do the right thing according to priority![[Pasted image 20230122195157.png]]
			- Order 
				- Execute children from left to right 
			- Stop Condition and Return Value 
				- until one child returns Success or Runningï¼Œ then return value accordingly 
				- or all children return Failureï¼Œthen return Failure 
			- If Stop and Return Running 
				- the next execution will start from the running action
		- Parallel
			- Could do multiple things "at the same time"![[Pasted image 20230122195623.png]]
			- Order 
				- Logically execute all children simultaneously 
			- Stop Condition and Return Value 
				- Return Success when at least M child nodes (between 1 and N) have succeeded 
				- Return Failure when at least N - M + 1 child nodes (between 1 and N) have failed 
				- Otherwise return Running 
			- If Stop and Return Running 
				- the next execution will start from the running actions
		- Decorator
			- A special kind of control node with a single child node
			- Usually some behavior pattern which is commonly used
			- For example, some common policies: 
				- Loop execution 
				- Execute once 
				- Timer 
				- Time Limiter 
				- Value Modifier 
				- Etc.
	- Tick a Behavior Tree
		- The tick of BT is like thinking 
		- Every tick start from root node 
		- Go through different nodes from up to down, left to right 
		- Each node must return failure, success or running
	- Precondition
		- Simplify behavior tree structure with preconditions![[Pasted image 20230122200627.png]]
	- Blackboard
		- the memory of behavior tree
		- æ¯ä¸ªèŠ‚ç‚¹å¯èƒ½ä¼šå¾€blackboardé‡Œé¢å†™å…¥å˜é‡
	- Pros
		- Modular, Hierarchical organization 
			- each subtree of a BT can be seen as a module, with a standard interface given by the return statuses 
		- Human readable 
		- Easy to maintain 
			- Modification only affect parts of tree
		- Reactivity 
			- Think every tick to quickly change behavior according to environment 
		- Easy to Debug 
			- Every tick is a whole decision making process, so taht it is easy to debug
	- Cons
		- Each tick starts from root node which costs much more 
		- The more reactive, the more condition to be checked and the more costs per tick
- Hierarchical Tasks Network 
- Goal Oriented Action Planning 
- Monte Carlo Tree Search 
- Deep Learning