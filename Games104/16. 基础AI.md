- Navigation
- Steering
- Crowd Simulation 
- Sensing 
- Classic Decision Making Algorithms

### Navigation
- Navigation Steps
	- Map representation
		- Walkable Area
			- We need to tell AI agents where they can walk â€“ Walkable area
			- åŒä¸€ä¸ªåœ°å›¾å¯¹äºä¸åŒçš„agentå¯è¡Œèµ°åŒºåŸŸå¯èƒ½æ˜¯ä¸ä¸€æ ·çš„ï¼Œæ¯”å¦‚å£«å…µå’Œå¦å…‹ï¼Œé£æœº
			- Walkable area of players is determined by character motion capabilities
				- Physical Collision
				- Climbing slope/height
				- Jumping distance
			- Simulating movement of AI agents as players costs too much
			- AI agents are still expected to have the same walkable area as players
			- å¯è¡Œèµ°åŒºåŸŸè¡¨è¾¾å½¢å¼
				- Waypoint Network
					- Network connecting critical points (waypoints) from the map
					- Waypoint sources: 
						- Designed important locations 
						- Corner points to cover walkable area 
						- Internal points to connect near-by waypoints adding flexibility to navigation
					- Usage of waypoint network is similar to subway system
						- Find the nearest points to get on and off the network
						- Plan the path on the waypoint network
					- Pros:
						- Easy to implement
						- Fast path finding, even for large maps 
					- Cons: 
						- Limited flexibility: must go to the nearest point in the network before navigation 
						- Waypoint selection requires manual intervention
				- Grid 
					- Intuitive discretization of map
					- Uniform subdivision into small regular grid shapes
					- Common grid shapes 
						- Square
						- Triangle 
						- Hexagon
					- Grid property could be modified in runtime to reflect dynamic environmental changes
					- Pros: â€¢
						- Easy to implement 
						- Uniform data structure 
						- Dynamic 
					- Cons: 
						- Accuracy depends on grid resolution
						- Dense grid lowers pathfinding performanceï¼Œæ ¼å­å¾ˆå¯†é›†çš„è¯ï¼Œæ•ˆç‡ä¼šä½ï¼Œå› ä¸ºçº¿æ€§çš„å­˜å‚¨æ–¹å¼å¯¼è‡´cache miss
						- High memory consumption 
						- Hard to handle 3D mapï¼Œå¾ˆéš¾è¡¨è¾¾å±‚æ¬¡ç»“æ„ï¼Œæ¯”å¦‚æ¡¥
				- Navigation Mesh
					- Solves the problem of representing overlapped walkable areas 
					- Approximates the walkable area of character controller based on physical collision and motion capabilities
					- Lowers network density to boost pathfinding performance
					- Convex Polygon of NavMesh
						- Pathfinding generates a series of polygon (Polygon Corridor) need to walk through
						- Convexity guarantees the final path is limited in the polygon and two adjacent polygons have only one common edge (Portal)ï¼ˆä¸¤ä¸ªå‡¸å¤šè¾¹å½¢ä¹‹é—´åªä¼šæœ‰ä¸€ä¸ªå…¬å…±è¾¹ï¼‰
						- å¯»è·¯çš„æ—¶å€™è¦ç©¿è¿‡ä¸€ä¸ªå‡¸å¤šè¾¹å½¢ï¼Œåªä¼šç©¿è¿‡ä¸€æ¬¡ï¼Œå¦‚æœæ˜¯å‡¹å¤šè¾¹å½¢ï¼Œå¯èƒ½ä¼šæœ‰å¤šæ¬¡
					- Pros: 
						- Support 3D walkable surface 
						- Accurate ï¼ˆç²¾ç¡®ï¼‰
						- Fast in pathfinding 
						- Flexible for selection of start/destination 
						- Dynamic 
					- Cons: 
						- Complex generation algorithm 
						- Not support 3D spaceï¼ˆä¸èƒ½ç»™ç›´å‡é£æœºè¿™ç§agentå¯»è·¯ï¼‰
				- Sparse Voxel Octreeï¼ˆå…«å‰æ ‘ï¼‰
					- Represents â€œflyableâ€ 3D space
					- Similar to spatial partitioning
					- Finest level voxels represents complicated boundary
					- Coarser-level voxels represents uniform regions
					- å­˜å‚¨æ¯”è¾ƒè´¹ï¼Ÿ
					- å¯»è·¯æ¯”è¾ƒéº»çƒ¦ï¼Ÿ
	- Path finding
		- Distances in map representations can be abstracted as edge costs in graph![[Pasted image 20230122131030.png]]
		- Pathfinding can be abstracted as shortest path problem in non-directional graph
		- Depth-First Search
			- Expand most recently added
		- Breadth-First Search
			- Expand least recently added
		- Dijkstra Algorithm
		- A Star (A*)
			- implement![[Pasted image 20230122143215.png]]
			- Expand lowest cost in list 
			- Distance is known distance from source + heuristic 
			- Greedy: stops when reaches the goal
			- Cost calculation
				- Cost calculation: ğ‘“ ğ‘› = ğ‘”(ğ‘›) + â„(ğ‘›) 
				- ğ‘”(ğ‘›): the exact cost of the path from the start to node ğ‘› 
				- â„(ğ‘›): the estimated cost from node ğ‘› to the goal
			- Heuristic On Grids
				- For 4 directions of movement, we can use Manhattan distance
				- ğ·1: cost for moving to the adjacent node
				- â„(ğ‘›) = ğ·1 âˆ™ (ğ‘‘ğ‘¥ + ğ‘‘ğ‘¦)
					- ğ‘‘ğ‘¥ = |ğ‘¥ğ‘› âˆ’ ğ‘¥ğ‘”ğ‘œğ‘ğ‘™| , ğ‘‘ğ‘¦ = |ğ‘¦ğ‘› âˆ’ ğ‘¦ğ‘”ğ‘œğ‘ğ‘™|
			- Heuristic On NavMesh
				- Multiple choices when evaluating cost on NavMesh 
					- Using polygon centers or vertices usually over-estimateï¼ˆè¿‡é«˜ä¼°è®¡ï¼‰ the cost 
					- Using hybridï¼ˆæ··åˆï¼‰ method introducesï¼ˆå¼•å…¥ï¼‰ too many points to check
					- Midpoints of edges â€“ a good balance
				- On a navigation mesh that allows any angle of movement, use a straight line distance 
				- Use midpoint of the edge entering the current node as node cost calculation point 
				- ğ·: the cost for moving unit distance in any direction
					- â„(ğ‘›) = ğ· âˆ™ æ¬§æ‹‰è·ç¦»
			- Heuristic
				- â„(ğ‘›) controls A* behavior:
					- With 100% accurate estimates, get shortest paths quickly
					- Too low, continue to get shortest paths, but slow down
					- Too high, exit early without shortest path
				- Balance between pathfinding speed and accuracy
	- Path smoothing
		- Why we need path smoothing â€¢
			- Zigzag, many unnecessary turns ï¼ˆè·¯å¾„å¾ˆæ›²æŠ˜ï¼‰
		- â€œString Pullingâ€ â€“ Funnel Algorithmï¼ˆçƒŸå›±ç®—æ³•ï¼‰
			- The scope of the funnel is the possible scope of the path 
			- Narrow the funnel if necessary to fit the portal
			- Terminate when the goal is in the funnel
			- å›¾1![[Pasted image 20230122143904.png]]
			- å›¾2![[Pasted image 20230122143915.png]]
	- NavMesh Generation 
		- Voxelization
			- Sample collision scene by voxelization
		- Region Segmentation
			- Calculate the distance of each voxel to border 
			- Mark border voxels by AgentRadius to avoid clipping
			- Watershed Algorithm
				- Gradually â€œfloodâ€ the â€œterrainâ€ 
				- Form â€œwatershedâ€ (dividing ridge) when â€œpoolsâ€ meet
			- Segment the â€œneighboringâ€ voxels into regions to provide a good basis for polygon mesh
			- Regions donâ€™t have overlapping voxels in 2D
		- Mesh Generation
			- Generate NavMesh from segmented regions
	- NavMesh Advanced Features
		- Polygon Flag
			- Useful for marking terrain types: plains, mountain, water, etc. 
				- â€œPaint colorsâ€ to add user-defined regions 
				- Polygons generated from user-defined regions have special flag
		- Tile
			- æŠŠä¸–ç•Œåˆ†å—ï¼Œéšœç¢ç‰©ç§»åŠ¨çš„è¯ï¼Œåªæ›´æ–°éšœç¢ç‰©æ‰€åœ¨çš„å—çš„navmesh
			- Fast for responding to dynamic objects 
			- Avoid rebuilding the entire NavMesh 
			- TileSize â€“ trade-off between pathfinding and dynamic rebuilding performance
		- Off-mesh Link
			- Allow agents to jump or teleport


### Steering
